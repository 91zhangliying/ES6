<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    // es6 类 es5 构造函数

    // 1) 了解构造函数的属性
   /*  function Animal(name){
      // 属性分为两种  实例上的属性  公有属性
      this.name=name
      this.arr=[1,2,3]
    }
    Animal.prototype.address={location:'山里'}
    let al=new Animal('猴子')
    let a2=new Animal('狗狗') */
    // console.log(al.arr===a2.arr);
    // console.log(al.address===a2.address);
    // 每个实例都有一个__proto__指向所属类的原型
    // console.log(a1.__proto__===Animal.prototype)
    // console.log(a1.constructor === Animal)
    // console.log(Animal.__proto__===Function.prototype)
    // console.log(a1.__proto__.__proto__===Object.prototype)
    // console.log(Object.prototype.__proto__)

    // 2) 类的继承
    function Animal(name){
      // 属性分为两种  实例上的属性  公有属性
      this.name=name
      this.eat='吃肉'
    }
    Animal.prototype.address={location:'山里'}

    function Tiger(name){
       this.name=name
       this.age=10
       Animal.call(this)
    }
    // 继承父类的公共属性/方法
    // Tiger.prototype.__proto__=Animal.prototype 等价 Object.setPrototypeOf(Tiger.prototype,Animal.prototype) [es6的写法]
    // Object.create es5的方法
    // function create(parentPrototype){
    //    let Fn=function(){}
    //    Fn.prototype=parentPrototype//当前函数的原型，只有父类的原型
    //    let fn=new Fn();
    //    fn.constructor=Tiger
    //    return Fn //当前实例可以拿到animal.prototype
    // }
    // Tiger.prototype.__proto__=Object.create(Animal.prototype,{constructor:{value:Tiger}})
    Tiger.prototype=new Animal();
    Tiger.prototype.say=function(){
      console.log('说话');
    }
    Tiger.prototype=Animal.prototype

    // 1) 继承父类实例上的属性
    let tiger=new Tiger()
    console.log(tiger.eat);
    console.log(tiger.constructor)
    console.log(tiger.address);
  </script>
</body>
</html>