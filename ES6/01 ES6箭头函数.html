<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // #### 1.ES6的基础语法
        // + 1.let和const
        let a = 12;
        a = 13;
        console.log(a); //=>13

        // + 2.基于const创建变量，变量存储的值不能被修改(常量)
        const b = 12;
        b = 13; //=>Uncaught TypeError: Assignment to constant variable.
        console.log(b);

        //#### 2.let和var的区别
        // + 1.let不存在变量提升(当前作用域中不能在let声明前使用变量)
        // + 2.同一个作用域中 let不允许重复声明
        // + 3.let解决了typeof的一个暂时性死区问题
        // + 4.全局作用域中使用let声明的变量并没有给window加上对应的属性
        // + 5.let会存在块作用域(除对象以外大括号都可被看作块级私有作用域)

        /*           
        //#### 3.箭头函数及this问题
           + 1.ES6中新增了创建函数的方式:'箭头函数'
           + 2.真实项目中是箭头函数和function这种普通函数混合使用

           > 1.箭头函数简化了创建函数代码
           const fn=([形参])=>{
               //函数体 return
           };
           fn([实参]);

           > 2.形参只有一个，小括号可以不加
           const fn=n=>{};

           >3.函数体中只有一句话，并且是return XXX的，可以省略大括号和return等
           const fn=n=>n*10; 
        */

        function fn(n) {
            return function(m) {
                return m + (++n);
            }
        }
        //改写箭头函数：
        const fn = (n) => m => m + (++n)

        /*  >4.箭头函数中没有arguments，但是可以基于剩余运算符获取实参集合，而且ES6中式支持给形参设置默认值的
         - ...arg:剩余运算符（把除第一项外的，其他剩余实参信息都存储到args这个数组集合中） */

        let obj = {};
        let fn = (context) => {
            console.log(arguments);
            //=>Uncaughe ReferenceError:arguments is not defined 箭头函数中没有arguments    
        };
        fn(obj, 10, 20, 30);
        fn();

        let obj = {};
        let fn = (context = window, ...args) => {
            console.log(args);
        };
        fn(obj, 10, 20, 30);//context的this:obj arg:[10,20,30]
        fn();//=>context的this:window arg[]

        /*  >5.箭头函数中没有自己的this，他里面用到的this，都是自己所处上下文中的this（真实项目中，一但涉及this问题，箭头函数慎用）
         */
        //箭头函数开始的执行主体是window
        window.name = 'WINDOW';
        let obj = {
            name: 'OBJ'
        }
        let fn = n => {
            console.log(this.name);
        }
        fn(10); //=>this:window
        fn.call(obj.onclick) = fn;// =>this:window  不是我们预期的OBJ
        document.body.onclick = fn;// =>this:window 不是我们预期的BODY

        //箭头函数开始的执行主体是window
        window.name = 'WINDOW';
        let fn = n => {
            console.log(this.name);
        }
        let obj = {
            name: 'OBJ'
        }
        obj.fn(10); //=>this:window

        //普通函数中有箭头函数，谁把普通函数执行，this就是谁
        let obj = {
            name: "OBJ",
            fn: function() {
                //=>this:obj普通函数是有自己的this的
                let f = () => {
                    console.log(this);
                }
                f(); //=>this:obj
                return f;
            }
        }
        let f = obj.fn();
        f(); //=>this:obj

        //真实项目中的一个应用
        let obj = {
            name: 'OBJ',
            fn: function() {
                //=>this:obj
                //=>原本期望的需求是：1s后把OBJ中的name改为“张三”
                //1.箭头函数最佳方案
                setTimeout(() => {
                    console.log(this); //=>OBJ
                    this.name = '张三';
                }, 1000)

                //2.普通函数的this是window
                setTimeout(function() {
                    console.log(this); //=>window
                    this.name = '张三';
                }, 1000);

                //3.把需要的变量存储起来
                let _this = this; //=>把需要的this提前用变量存储起来
                setTimeout(function() {
                    _this.name = 'jack'; //=>需要使用的时间拿出来用即可
                }, 1000);
            }
        }
        obj.fn();


    </script>
</body>
</html>