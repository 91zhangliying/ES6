<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // let const  不能重复声明  能够识别块级作用域({})  有暂时性死区(在声明执行 不能调用)
      // const 声明的是一个常量 对应的值不能修改；
      // 1.同一个堆内存地址
      const ary = [1, 2, 3]; // ary对应的值 是 AAFF00
      ary[0] = 100; //不会报错 因为给ary的是一个地址AAFF00；

      // 2.新开一个堆内存地址
      // ary = [];//会报错，ary重新定义一个堆内存地址 AAFF11

    // ### 箭头函数       
    // 普通函数
      var f1 = function (a, b) {
          console.log(this,`普通函数`) //this指向当前obj
          console.log(arguments,`普通函数`) //obj.f1(1,2,3)  arguments是当前传递的实参
          return 123
      };

    // 箭头函数
    var f2=(a,b)=>{
        console.log(this,`箭头函数`) //this指向windows
        console.log(arguments,`箭头函数`) // 666
        return 123
    }
    var obj={
        f1,//f1:f1
        f2
    }
    var arguments=666
    obj.f1(1,2,3)//this是obj;argument是类数组【1,2,3】
    obj.f2(100,200,300)//this指向windows arguments ; 箭头函数中 是把 this:windows 和 arguments:666 当作了普通变量去对待；
   
    /*  
    1.箭头函数中 是把 this 和 arguments 当作了普通变量去对待；
    2.也就是说 箭头函数中的this 和 arguments 都是去上级作用去中查找去了；
    3.对于箭头函数 来说  call apply bind 三者是没有任何作用的 
    */

    f2.call([],1,2)
    var temp=f1.bind([])  
    console.log(temp(),`bind改变this指向，只能改变一次`)  //  1.this指向[]  2.arguments:123  

    // 3.通过bind改变一次的this,不会再改变 如下还是[]
    var temp1=temp.bind([1,2,3])
    console.log(temp1(),`bind只能改变一次,第二次不起作用，还是第一次bind的结果`);//  1.this指向[]  2.arguments:123  3.通过bind改变一次的，再用call apply bind不起作用


    // ### ...剩余运算符
    var f3=(a,b,...c)=>{
      console.log(a,b,...c,`...剩余运算符`);// ...c我们成为剩余运算符：把剩下的实参都放到c这个数组中
      return a+b
    }
    f3(1,2,4,3)

    // 用箭头函数实现不定项求和  
    // eval把字符串转换成表达式  如:console.log(eval('1+2+3'))//=>6
    // 写法1
    var sum=(...ary)=>{
        let itemary=ary.join("+")
        let total=eval(itemary)
        console.log(total,`不定项求和`)
        return total
    }    
    console.log(sum(1,2,3,4,5))

    // 写法2
    var sum1=(...ary)=>eval(ary.join('+'))
    var total=sum1(1,2,3)
    console.log(total,`sum1的total`);
    

  /* 
    1.for    循环 是根据指定的循环次数循环的
    2.for in 循环一般只用来循环普通对象，不会用来循环数组
      循环 for(let k  in obj){} k 是obj的键值对中的属性名 一般只用来循环 普通对象的 
      for in 他会把原型上自定义添加的属性获取到 
    3.for of 循环  for(let val of obj){}  val 是obj的键值对中的值；只能用来循环可迭代(有索引的)的数据类型；
  */

  // 写法3
  var sum2=(...ary)=>{
      let count=0
      for(let i=0;i<ary.length;i++){
          count+=ary[i]
      }
      return count
    }
    let sum2Total=sum2(1,2,3,4,5)
    console.log(sum2Total,`for循环实现 sum2的total`)

    // for in 一般用用来循环对象，不循环数组
    var sum3=(...ary)=>{
      let count=0
      for(let key in ary){
          console.log(key,typeof key)//key是字符串，key是obj中的属性名
          count+=ary[key]
      }
      return count
    }
    let sum3Total=sum3(1,2,3,4,5,6)
    console.log(sum3Total,`for in  实现求和sum3的total`)

    // for of 
    var sum3=(...ary)=>{
      let count=0
      for(let key of ary){
          console.log(key,typeof key)//key是obj中的属性值，
          count+=ary[key]
      }
      return count
    }
    let sum3Total=sum3(1,2,3,4,5,6)
    console.log(sum3Total,`for in  实现求和sum3的total`)

    

  var obj = { a: 123, b: 234, c: 345 };
  Object.prototype.qqq = 100;
  for (let k in obj) {
    if (obj.hasOwnProperty(k)) {
      console.log(k)//qqq是自定义
    }
  }

  var obj = {
    0: 123,
    1: 234,
    2: 345,
    length: 3,
    [Symbol.iterator]: function () {
      // index用来记遍历圈数
      let index = 0;
      let next = () => {
        return {
          value: this[index],
          done: this.length == index++
        }
      }
      return {
        next
      }
    }
  };

  function fn3(...ary) {
    console.log(ary);
  }
  Math.max(...[1, 2, 3, 2, 1, 3, 5, 2]);// 展开运算符

    </script>
  </body>
</html>
